name: Auto Label PRs

on:
  pull_request:
    types: [opened, synchronize, edited]

permissions:
  contents: read
  issues: write
  pull-requests: write

jobs:
  label:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v2

      - name: Add or remove labels based on PR checklist selection and update PR body
        uses: actions/github-script@v5
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const prBody = context.payload.pull_request.body;
            // Extrair os n√∫meros das issues mencionadas no corpo da PR
            const issueNumbers = Array.from(prBody.matchAll(/(closes|fixes|resolves)\s+#(\d+)/gi)).map(match => match[2]);        

            const icon_bug = []; 
            const icon_enhancement = [];
            const icon_feature = [];
            const icon_docs = [];
            const icon_refactor = [];
            const icon_test = [];
            const icon_security = [];
            const icon_ui = [];
            const icon_config = [];
            const icon_revert = [];
            const icon_integration = [];
            const icon_hotfix = [];
            const icon_experiment = [];
            const icon_i18n = [];
            const icon_release = [];
            const icon_discussion = [];
            const icon_idea = [];
            const icon_question = [];

            if (issueNumbers.length > 0) {
                // Processar cada issue mencionada no corpo da PR
                for (const issueNumber of issueNumbers) {
                  const { data: issue } = await github.rest.issues.get({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issueNumber,
                  });

                  // Verificar se o t√≠tulo da issue cont√©m os √≠cones
                  if (issue.title.includes('üêû')) icon_bug.push('üêû');
                  if (issue.title.includes('üå±')) icon_feature.push('üå±');
                  if (issue.title.includes('üìù')) icon_docs.push('üìù');
                  if (issue.title.includes('üöÄ')) icon_enhancement.push('üöÄ');
                  if (issue.title.includes('üõ†Ô∏è')) icon_refactor.push('üõ†Ô∏è');
                  if (issue.title.includes('üß™')) icon_test.push('üß™');
                  if (issue.title.includes('üîí')) icon_security.push('üîí');
                  if (issue.title.includes('üé®')) icon_ui.push('üé®');
                  if (issue.title.includes('‚öôÔ∏è')) icon_config.push('‚öôÔ∏è');
                  if (issue.title.includes('üîÑ')) icon_revert.push('üîÑ');
                  if (issue.title.includes('üß©')) icon_integration.push('üß©');
                  if (issue.title.includes('üöë')) icon_hotfix.push('üöë');
                  if (issue.title.includes('üßë‚Äçüîß')) icon_experiment.push('üßë‚Äçüîß');
                  if (issue.title.includes('üåê')) icon_i18n.push('üåê');
                  if (issue.title.includes('üì¢')) icon_release.push('üì¢');
                  if (issue.title.includes('üí¨')) icon_discussion.push('üí¨');
                  if (issue.title.includes('üí°')) icon_idea.push('üí°');
                  if (issue.title.includes('‚ùì')) icon_question.push('‚ùì');
                }                
            }

            const prNumber = context.payload.pull_request.number;
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            // Adicionar labels conforme √≠cones
            const labelsToAdd = [];
            const labelsToRemove = [];

            if (icon_bug.length > 0) labelsToAdd.push('üêû Bug'); else labelsToRemove.push('üêû Bug');
            if (icon_feature.length > 0) labelsToAdd.push('üå± Feature Request'); else labelsToRemove.push('üå± Feature Request');
            if (icon_docs.length > 0) labelsToAdd.push('üìù Documentation'); else labelsToRemove.push('üìù Documentation');
            if (icon_enhancement.length > 0) labelsToAdd.push('üöÄ Enhancement'); else labelsToRemove.push('üöÄ Enhancement');
            if (icon_refactor.length > 0) labelsToAdd.push('üõ†Ô∏è Refactor'); else labelsToRemove.push('üõ†Ô∏è Refactor');
            if (icon_test.length > 0) labelsToAdd.push('üß™ Test'); else labelsToRemove.push('üß™ Test');
            if (icon_security.length > 0) labelsToAdd.push('üîí Security'); else labelsToRemove.push('üîí Security');
            if (icon_ui.length > 0) labelsToAdd.push('üé® UI/UX Update'); else labelsToRemove.push('üé® UI/UX Update');
            if (icon_config.length > 0) labelsToAdd.push('‚öôÔ∏è Configuration Update'); else labelsToRemove.push('‚öôÔ∏è Configuration Update');
            if (icon_revert.length > 0) labelsToAdd.push('üîÑ Revert Changes'); else labelsToRemove.push('üîÑ Revert Changes');
            if (icon_integration.length > 0) labelsToAdd.push('üß© Integration'); else labelsToRemove.push('üß© Integration');
            if (icon_hotfix.length > 0) labelsToAdd.push('üöë Hotfix'); else labelsToRemove.push('üöë Hotfix');
            if (icon_experiment.length > 0) labelsToAdd.push('üßë‚Äçüîß Experimentation'); else labelsToRemove.push('üßë‚Äçüîß Experimentation');
            if (icon_i18n.length > 0) labelsToAdd.push('üåê I18n/L10n'); else labelsToRemove.push('üåê I18n/L10n');
            if (icon_release.length > 0) labelsToAdd.push('üì¢ Release'); else labelsToRemove.push('üì¢ Release');
            if (icon_discussion.length > 0) labelsToAdd.push('üí¨ Discussion'); else labelsToRemove.push('üí¨ Discussion');
            if (icon_idea.length > 0) labelsToAdd.push('üí° Idea'); else labelsToRemove.push('üí° Idea');
            if (icon_question.length > 0) labelsToAdd.push('‚ùì Question'); else labelsToRemove.push('‚ùì Question');


            // Adicionar ou remover as labels no PR
            if (labelsToAdd.length > 0) {
              await github.rest.issues.addLabels({
                issue_number: prNumber,  // Usar o n√∫mero do PR
                owner: owner,
                repo: repo,
                labels: labelsToAdd
              });
            }

            // Remover as labels do PR
            for (const label of labelsToRemove) {
              await github.rest.issues.removeLabel({
                issue_number: prNumber,  // Usar o n√∫mero do PR
                owner: owner,
                repo: repo,
                name: label
              }).catch(error => {
                if (error.status !== 404) throw error;  // Ignorar erro se a label n√£o for encontrada
              });
            }

            // Fun√ß√£o para gerar a se√ß√£o "Tipo de Mudan√ßa" com base nos √≠cones encontrados
            function generateTipoMudanca(icon_bug, icon_enhancement, icon_feature, icon_docs, icon_refactor, icon_test, icon_security, icon_ui, icon_config, icon_revert, icon_integration, icon_hotfix, icon_experiment, icon_i18n, icon_release, icon_discussion, icon_idea, icon_question) {
                let tipoMudanca = "> N√£o houve mudan√ßas";

                // Adiciona mudan√ßas espec√≠ficas conforme os √≠cones encontrados
                const changes = [];
                if (icon_bug.length > 0) changes.push('üêû Corre√ß√£o de bug');
                if (icon_feature.length > 0) changes.push('üå± Nova funcionalidade solicitada');
                if (icon_docs.length > 0) changes.push('üìù Altera√ß√£o na documenta√ß√£o');
                if (icon_enhancement.length > 0) changes.push('üöÄ Melhoria de desempenho');
                if (icon_refactor.length > 0) changes.push('üõ†Ô∏è Refatora√ß√£o de c√≥digo sem mudar a funcionalidade');
                if (icon_test.length > 0) changes.push('üß™ Testes (adicionando ou corrigindo testes)');
                if (icon_security.length > 0) changes.push('üîí Melhoria de seguran√ßa');
                if (icon_ui.length > 0) changes.push('üé® Altera√ß√µes na interface ou layout');
                if (icon_config.length > 0) changes.push('‚öôÔ∏è Atualiza√ß√£o de configura√ß√£o');
                if (icon_revert.length > 0) changes.push('üîÑ Revers√£o de mudan√ßas');
                if (icon_integration.length > 0) changes.push('üß© Integra√ß√£o com servi√ßos externos ou m√≥dulos internos');
                if (icon_hotfix.length > 0) changes.push('üöë Corre√ß√£o emergencial em produ√ß√£o');
                if (icon_experiment.length > 0) changes.push('üßë‚Äçüîß Experimenta√ß√£o ou prot√≥tipo');
                if (icon_i18n.length > 0) changes.push('üåê Internacionaliza√ß√£o ou localiza√ß√£o');
                if (icon_release.length > 0) changes.push('üì¢ Lan√ßamentos de novas vers√µes ou atualiza√ß√µes');
                if (icon_discussion.length > 0) changes.push('üí¨ T√≥picos que exigem discuss√£o e brainstorm');
                if (icon_idea.length > 0) changes.push('üí° Ideias iniciais que podem se tornar tarefas futuras');
                if (icon_question.length > 0) changes.push('‚ùì D√∫vidas e pontos que precisam de feedback ou esclarecimento');

                // Atualizar a vari√°vel tipoMudanca com as op√ß√µes selecionadas
                if (changes.length > 0) {
                    tipoMudanca = changes.map(change => `> [x] ${change}`).join('\n');
                }

                return tipoMudanca;
            }

            // Modificar o corpo da PR com base nas labels
            let updatedBody = prBody;

            // Gerar a se√ß√£o "Tipo de Mudan√ßa" usando a fun√ß√£o
            const tipoMudanca = generateTipoMudanca(icon_bug, icon_enhancement, icon_feature, icon_docs, icon_refactor, icon_test, icon_security, icon_ui, icon_config, icon_revert, icon_integration, icon_hotfix, icon_experiment, icon_i18n, icon_release, icon_discussion, icon_idea, icon_question);

            // Substituir ou atualizar o corpo do PR com a se√ß√£o "Tipo de Mudan√ßa"
            //const prUpdateBody = `${context.payload.pull_request.body}\n\n### Tipo de Mudan√ßa\n${tipoMudanca}`;
            updatedBody = updatedBody.replace(/### üîß Tipo de Mudan√ßa([\s\S]*?)###/g, `### üîß Tipo de Mudan√ßa\n${tipoMudanca}\n\n###`);

            // Atualizar o corpo da PR com as novas informa√ß√µes
            await github.rest.pulls.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber,
                body: updatedBody,
            });
